---
layout:     post
title:      "数据结构-3.队列与广度优先搜索"
subtitle:   "数据结构学习"
date:       2019-03-01
author:     "本人"
header-img: "img/2019/summary/js.jpeg"
tags:
    - 数据结构
---


## 深度优先搜索与广度优先搜索

假设我们有这样的一棵满二叉树树

```
     A
   /   \
  B     C
 / \   / \
D   E F   G
```

### 深度优先搜索(Depth First Search)

深度优先搜索是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。

以上面二叉树为例，深度优先搜索的顺序为：`A => B => D => E => C => F => G`。

怎么实现这个顺序呢 ？深度优先搜索二叉树是先访问根结点，然后**遍历左子树接着是遍历右子树**，因此我们可以利用**栈的先进后出**的特点，

这里不拓展学习。


### 广度优先搜索(Breadth First Search)

广度优先搜索又叫宽度优先搜索或横向优先搜索，是从**根结点开始沿着树的宽度搜索遍历**，上面二叉树的遍历顺序为：`A => B => C => D => E => F => G`.

可以利用**队列实现广度优先搜索**。

1. 结点的处理顺序是什么？

在第一轮中，我们处理根结点。

在第二轮中，我们处理根结点旁边的结点；

在第三轮中，我们处理距根结点两步的结点；等等等等。

与树的层序遍历类似，越是接近根结点的结点将越早地遍历。

如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。

也就是说，第一次找到目标结点时，你已经处于最短路径中。

2. 队列的入队和出队顺序是什么？

首先将根结点排入队列。

然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。

值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。

结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即**先进先出（FIFO）**。

这就是我们在 BFS 中使用队列的原因。

