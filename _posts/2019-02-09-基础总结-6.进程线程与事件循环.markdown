---
layout:     post
title:      "基础总结-6.进程线程与事件循环"
subtitle:   "js 基础总结"
date:       2019-02-09
author:     "本人"
header-img: "img/2019/summary/js.jpeg"
tags:
    - 基础总结
---


## 进程与线程

进程是`CPU`资源分配的最小单位。

线程是`CPU`调度的最小单位。

进程与线程的关系好比下面的工厂与工人，进程作为工厂拥有唯一的工厂资源，而一个进程工厂里可以有很多工人线程。

![工厂与工人](/my-blog/img/2019/02/线程与进程.jpg)

因为 `javascript` 主要运行在浏览器端，为了禁止多个线程同时修改一个 `DOM` 节点，所以 `javascript` 在浏览器端被设计成为**异步单线程**的语言。


## 浏览器内核的进程

- Browser 进程

  主进程，主要负责页面管理以及管理其他进程的创建和销毁等，常驻的线程有：

    1. GUI渲染线程：主要负责**页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制**等。界面需要重绘或者由于某种操作引发回流时，将执行该线程。**该线程与JS引擎线程互斥**，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，浏览器才会去执行GUI渲染。
    2. JS引擎线程：该线程当然是主要负责**处理 JavaScript脚本，执行代码**。也是主要**负责执行准备好待执行的事件**，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。当然，**该线程与 GUI渲染线程互斥**，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。
    3. 事件触发线程：主要负责**将准备好的事件交给 JS引擎线程执行**。比如`setTimeout`定时器计数结束， `ajax`等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待JS引擎线程的执行。
    4. 定时器触发线程（宏任务）：顾名思义，负责执行异步定时器一类的函数的线程，如：`setTimeout`，`setInterval`。**主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。**
    5. HTTP请求线程（微任务）：顾名思义，负责执行异步请求一类的函数的线程，如：`Promise`，`anxios`，`ajax`等。**主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。**

- Render 进程

  浏览器渲染进程（浏览器内核），主要负责页面的渲染、JS执行以及事件的循环。


## 执行栈

执行栈就像是一个容器，任务都是在栈中执行。

执行栈也是栈的一种，先入后出。

主线程就像是操作员，负责执行栈中的任务。

当一个异步任务比如 `SetTimeout` `Promise`）入栈时，主线程判断该任务为异步任务，并把该任务交给异步处理模块处理，当异步处理模块处理完打到触发条件时，根据任务的类型，将回调函数压入任务队列。

当异步的代码块执行完毕，会由事件触发线程将回调函数加入任务队列，等待JS引擎线程执行。

任务队列就像是等待被加工的物品。

异步任务完成注册后会将回调函数加入任务队列等待主线程执行。

执行栈中的同步任务执行完毕后，会查看并读取任务队列中的事件函数，于是任务队列的函数结束等待状态，进入执行栈，开始执行。

![执行栈工作流程](/my-blog/img/2019/02/执行栈.jpeg)


## 宏任务和微任务

异步任务分为**宏任务和微任务**，任务队列中**宏任务队列可以有多个**，**微任务队列只有一个**。

**宏任务和微任务的执行方式在浏览器和 `Node` 中有差异。**

- 宏任务（macrotask）：`script(全局任务)`， `setTimeout`， `setInterval`， `setImmediate`， `I/O`， `UI rendering`
- 微任务（macrotask）：`process.nextTick`， `Promise.then()`， `Object.observe`， `MutationObserver`

**在微任务中 `process.nextTick` 优先级高于 `Promise`**

当一个异步任务入栈时，主线程判断该任务为异步任务，并把该任务交给异步处理模块处理，**当异步处理模块处理完达到触发条件时，根据任务的类型，将回调函数压入任务队列**。

  - 如果是宏任务，则新增一个宏任务队列。任务队列中的宏任务可以有多个来源。
  - 如果是微任务，则直接压入微任务队列队尾。


## Event Loop 事件循环

上面微任务宏任务的区别理清之后，终于可以到事件循环了。

那么问题来了，当执行栈空时，可以去执行任务队列中的回调函数了，那么会先从宏任务的回调函数还是微任务的回调函数开始执行呢？

由于 `script(全局任务)` 属于宏任务，因此当栈为空，同步任务任务执行完毕时，会**先执行微任务队列里的全部回调函数**。

微任务队列里的回调全部执行完毕后，会清空微任务队列，并执行宏任务队列中最前排的回调。

执行宏任务的过程中，遇到微任务，依次加入微任务队列。

当最前排的宏任务队列的回调执行完毕后，再次读取微任务队列，如果微任务队列长度不为0，则会再次执行执行完微任务队列中的回调。

由此往复。

![事件循环](/my-blog/img/2019/02/任务队列.png)
