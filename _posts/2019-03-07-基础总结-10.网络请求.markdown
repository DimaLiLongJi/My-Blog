---
layout:     post
title:      "基础总结-10.网络请求"
subtitle:   "js 基础总结"
date:       2019-03-07
author:     "本人"
header-img: "img/2019/summary/js.jpeg"
tags:
    - 基础总结
---


## 输入url之后发生了啥？

1. DNS 解析:将域名解析成 IP 地址
2. TCP 连接：TCP 三次握手
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手


## URL

URL（Uniform Resource Locator），**统一资源定位符，用于定位互联网上资源**，俗称网址。

遵守以下的语法规则：

`scheme://host.domain:port/path/filename`

如： `https://mp.weixin.qq.com/s/jjL4iA7p6aYEAQyWhn4QbQ`

各部分解释如下：

1. scheme - 协议的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
2. host - 定义域主机（http 的默认主机是 www）
3. domain - 定义因特网域名，比如 `weixin.qq.com`
4. port - 定义主机上的端口号（http 的默认端口号是 80）
5. path - 定义服务器上的路径（如果省略，则文档必须位于服务器的根目录中）。
6. filename - 定义文档/资源的名称


## DNS 解析

计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。

我们经常访问的 URL 就是带着域名的一部分。

### ip 地址

ip地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

IP 地址是一个 **32 位的二进制数**，比如 `127.0.0.1` 为本机 IP。

### DNS 服务

用户在浏览器上输入 `https://www.baidu.com` 的时候，浏览器并不知道要去访问什么 IP 地址，因此 DNS 服务就出现了。

DNS 服务提供通过**域名查找 IP 地址**，或逆向**从 IP 地址反查域名**的服务。

DNS 是一个网络服务器，域名解析简单来说就是在 DNS 上记录一条信息记录。

例如 `baidu.com => 220.114.23.56（服务器外网IP地址）:80（服务器端口号）`

浏览器会按照下面的顺序去解析域名：

1. 浏览器缓存 => 浏览器会按照一定的频率缓存 DNS 记录
2. 操作系统缓存 => 如果浏览器找不到，则会去操作系统中查询
3. 路由器缓存 => 操作系统找不到，则去路由器缓存中查找
4. ISP（Internet Service Provider） 的 DNS 服务器 => 网络服务供应商（电信 联通 网通）有专门的 DNS 服务器应对 DNS 查询请求
5. 根服务器 => ISP 查询不到，则像根服务器发出请求进行尾递归查询 **根域名服务器（.cn） => 具体域名服务器（.baidu）=> xxx.baidu.cn 域名服务器**

`浏览器 => 浏览器缓存 => 操作系统缓存 => 路由器缓存 => ISP DNS 服务器 => 根域名服务器（.cn） => 具体域名服务器（.baidu）=> xxx.baidu.cn 域名服务器`


## 发起 TCP 链接

1. Client  =>  (SYN=1，Seq=X)  =>  Service
2. Client  <=  (SYN=1，ACK=X+1，Seq=Y)  <=  Service
3. Client  =>  (ACK=Y+1，Seq=Z)  =>  Service

![TCP三次握手](/my-blog/img/2019/03/发起tcp请求.jpg)

**三次握手的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**

在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，


## 发送 HTTP 请求

HTTP 协议是个无状态协议，不会保存状态。

### GET 与 POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。

副作用与幂等
 
- 副作用：指对服务器上的资源做出改变
- 幂等：发出X次与Y次请求，服务器上的资源是相同的

1. Get 多用于 无副作用，幂等场景；其他多用于 有副作用 非幂等场景
2. Get 请求能缓存，Post 不能
3. Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
4. Post 可以通过 `request body` 来传输比 Get 更多的数据，Get 没有这个技术
5. 浏览器规定的URL有长度限制，会影响 Get 请求，不是 RFC 规定的
6. Post 支持更多的编码类型且不对数据类型限制

### 头部信息（请求头 响应头）

（通用）Cache-Control 缓存策略
（通用）Connection 优先的连接类型，比如 keep-alive
（请求头）User-Agent 客户端信息
（请求头）Referer 浏览器所访问的前一个页面
（响应头）Age	资源在代理缓存中存在的时间

### RESTFUL API

`RESTful` 的核心思想就是，客户端发出的数据操作指令都是**动词 + 宾语**的结构。比如，`GET /users`这个命令，GET是动词，/user是宾语。

动词通常就是五种 `HTTP` 方法，对应 `CRUD` 操作。

1. GET：读取（Read）
2. POST：新建（Create）
3. PUT：更新（Update）
4. PATCH：更新（Update），通常是部分更新
5. DELETE：删除（Delete）


## 服务器处理并返回

### 状态码

- 1XX 正在处理

- 2XX 成功

1. 200 OK，表示从客户端发来的请求在服务器端被正确处理
2. 204 No content，表示请求成功，但响应报文不含实体的主体部分
3. 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
4. 206 Partial Content，进行范围请求

- 3XX 重定向

1. 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
2. 302 found，临时性重定向，表示资源临时被分配了新的 URL
3. 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
4. 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
5. 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

- 4XX 客户端错误

1. 400 bad request，请求报文存在语法错误
2. 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
3. 403 forbidden，表示对请求资源的访问被服务器拒绝
4. 404 not found，表示在服务器上没有找到请求的资源

- 5XX 服务器错误

1. 500 internal sever error，表示服务器端在执行请求时发生了错误
2. 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
3. 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求


## 浏览器解析页面（已请求页面为例）

1. 解析 HTML 生成 DOM
  - HTML一边解析生成token，一遍用掉token生成DOM
  - DOM 树解析的过程是一个**深度优先遍历**。即先构建当前节点的所有子节点，再构建下一个兄弟节点
  - script 标签会阻塞 DOM 树的解析。
2. 解析 CSS 规则树
  - 解析时 js 执行将暂停，直至 CSS 规则树就绪。
  - 浏览器在 CSS 规则树生成之前不会进行渲染。
3. 结合 DOM 树和 CSS 规则树，生成渲染树
  - 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
4. 根据计算好的信息绘制页面
  - **重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。**
  - **回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。**

## 断开连接 TCP 四次握手

Client 客户端方主动发起断开 TCP 连接。

1. Client  =>  (FYN=1，ACK=Z，Seq=X)  =>  Service
2. Client  <=  (ACK=X+1，Seq=Z)  <=  Service
3. Client  <=  (FYN=1，ACK=X，Seq=Y)  <=  Service
4. Client  =>  (ACK=Y，Seq=X)  =>  Service

![TCP断开](/my-blog/img/2019/03/tcp断开连接.png)

发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。

(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)

被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。

(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)

被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。

(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)

发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。

(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)


## HTTPS

HTTPS 还是**通过了 HTTP 来传输信息**，但是信息**通过 SSL和TLS 协议**进行了加密。

**当 HTTP 的 TCP 握手结束后会进行 TLS 握手**，然后就开始正式的传输数据

### TLS

TLS 协议位于传输层之上，应用层之下。

首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。

在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

1. 对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
2. 非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

### 过程

http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL协议用于对http协议传输的数据进行加密，从而诞生了https，现在的https使用的都是TSL协议

https在传输数据之前需要客户端和服务端之间进行一次握手，在握手的过程中将确立双方加密传输数据的密码信息，TSL／SSL协议不仅仅是一套加密传输的协议，TSL/SSL中使用了非对称加密，对称加密以及hash算法

握手过程：

1. 浏览器将**自己支持的一套加密规则**发送给服务器
2. 服务器从中选出一组加密算法和hash算法，并将自己的身份信息以证书的形式发回给浏览器，证书里面包含了**服务器地址，加密公钥，以及证书的颁发机构**等信息
3. 获得服务器证书后浏览器要做以下工作
    1. 验证证书的合法性（颁发证书的机构是否合法，证书中包含的服务器地址是否与正在访问的地址一致）如果证书受信任，则浏览器栏里会显示一个小锁头，否则会给出证书不受信的提示
    2. 如果证书受信任，或者是用户接受了不受信的证书，**浏览器会生成一串随机数的密码（对称公钥），并用证书中提供的公钥加密（非对称的公钥加密私钥）**
    3. 使用约定好的hash计算握手信息，并**使用生成的随机数（对称公钥）对消息进行加密，最后将之前生成的所有信息发送给服务器**
4. 服务器接收浏览器发来的数据之后要做以下工作
    1. **使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手信息，并验证hash是否与浏览器发来的一致**
    2. 使用密码加密一段握手信息，发送给浏览器
    3. 浏览器解密并计算握手信息的hash，如果与服务端发来的hash一致，此时握手过程结束，之后**所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密**




## 图片

- 计算图片大小

对于一张 100*100 像素的图片来说，图像上有 10000 个像素点。

如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位bit = 1 个字节Byte）

所以该图片大小大概为 39KB（(100 * 100) * 4 * 1 / 1024）

**8 位 = 1 个字节 ; 1024字节(b Byte)=1千字节(kb)**

- 图片加载优化

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：
   1. 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
   2. 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
   3. 照片使用 JPEG

- 其他优化

1. CSS 文件放在 `head` 中
2. 服务端开启文件压缩功能
3. 将 `script` 标签放在 `body` 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 `script` 标签放在任意位置然后加上 `defer` ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 `async` ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。
4. 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 `Webworker`。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。

- 如何一次几万条不卡住

应该一次渲染部分 DOM，那么就可以通过 `requestAnimationFrame` 来每 16 ms 添加部分DOM并刷新一次。
