---
layout:     post
title:      "基础总结-13.canvas"
subtitle:   "js 基础总结"
date:       2019-04-06
author:     "本人"
header-img: "img/2019/summary/js.jpeg"
tags:
    - 基础总结
---


## 关于canvas

日常作为cv码农， `canvas` 肯定是相当陌生。

正好有个面试问到了 `canvas` 那么就顺便学一下。

[canvas](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial) 是 `HTML5` 新增的，一个可以使用脚本(通常为 JavaScript )在其中绘制图像的 `HTML` 元素。

它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。

Canvas是由 `HTML` 代码配合高度和宽度属性而定义出的可绘制区域。

JavaScript 代码可以访问该区域，类似于其他通用的二维 API ，通过一套完整的绘图函数来动态生成图形。

好吧，其实 `canvas` 其实是一个绘制2D的画布 API。


## canvas API

[参考](https://juejin.im/post/5bfba4d6e51d452fd80f0f0d#heading-2)

- 路径与坐标
  1. `beginPath()`  起始（重置）当前路径
  2. `closePath()` 关闭该路径 将绘制指令重新转移到上下文
  3. `fill()`  填充当前绘图（路径）
  4. `stroke()` 绘制已定义的路径
  5. `moveTo( x, y )`  将笔触移动到指定的坐标(x,y)
  6. `clip()`  从原始画布剪切任意形状和尺寸的区域
  7. `scale( x, y )`  缩放当前绘图
  8. `translate( x, y )`  重新设置画布上的(0,0)位置
  9. `rotate( angle )`  选择当前绘图，单位为“弧度”，角度转弧度公式（`degrees*Math.PI/180`）
  10. `transform( m11, m12, m21, m22, dx, dy )`  替换绘图的当前转换矩阵
  11. `setTransform()`  将当前转换重置为单元矩阵，然后运行 `transform()`

- 绘制矩形
  1. `rect( x, y, width, height )`   绘制矩形
  2. `fillRect( x, y, width, height )`  绘制被填充的矩形
  3. `strokeRect( x, y, width, height )`  绘制矩形（无填充）
  4. `clearRect( x, y, width, height )` 清除指定的矩形内的像素

- 绘制直线与曲线
  1. `lineTo( x, y )`  绘制一条从当前位置到指定的坐标(x,y)的直线
  2. `quadraticCurveTo( cp1x, cp1y , x ,y )`  创建二次贝塞尔曲线 (cp1x,cp1y) 控制点    (x,y)结束点
  3. `bezierCurveTo( cp1x, cp1y ,cp2x , cp2y ,x , y )`  （cp1x,cp1y）控制点1   (cp2x,cp2y) 控制点2  (x,y)结束点
  4. `arc( x, y, radius, startAngle, endAngle, anticlockwise)`  绘制圆或圆弧
  5. `arcTo( x1, y1, x2, y2, radius)`  根据给定点画圆弧，再以直线连接两个点
  6. `isPointInPath( x, y )`  检测指定的点是否在当前路径中，在则返回true
  7. `lineCap`  设置或返回线条的结束点样式（`butt、round、square`）
  8. `lineJoin`  设置或返回当两条线交汇时，边角的类型（`bevel、round、miter`）
  9. `lineWidth`  设置或返回当前的线条宽度
  10. `miterLimit`  设置或返回最大斜接长度

- 设置颜色样式
  1. `fillStyle`  设置或返回用于填充绘画的颜色、渐变或模式
  2. `strokeStyle`  设置或返回用于笔触的颜色、渐变或模式
  3. `shadowColor`  设置或返回用于阴影的颜色
  4. `shadowBlur`   设置或返回用于阴影的模糊级别
  5. `shadowOffsetX`  设置或返回阴影与形状的水平距离
  6. `shadowOffsetY`  设置或返回阴影与形状的垂直距离
  7. `font`  设置或返回文本内容的当前字体属性（和css的font一样）
  8. `textAlign`  设置或返回文本内容的当前对齐方式
  9. `textBaseline`  设置或返回在绘制文本时使用的当前文本基线
  10. `fillText( text, x, y )`  在画布上绘制“被填充”的文本
  11. `strokeText( text, x, y )`  在画布上绘制文本（无填充）
  12. `measureText( text )`  返回包含指定文本宽度的对象（属性width获取宽度）
  13. `globalAlpha`  设置或返回绘图的当前alpha或透明度
  14. `globalCompositeOperation`  设置或返回新图像如何绘制到已有的图像上

- 线性渐变
  1. `createLinearGradient( x0, y0, x1, y1 )`  创建线性渐变
  2. `createPattern( image/canvas/video, repeat )`  在指定的方向内重复绘制指定的元素
  3. `createRadialGradient( x0, y0, r0, x1, y1, r1 )` 创建径向渐变
  4. `addColorStop( stop, color )`  规定渐变对象中的颜色和停止位置

- **图片**
  1. `drawImage( image/canvas, x, y )`、`drawImage( image/canvas, x, y, width, height )`、`drawImage( image/canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )`  在画布上绘制图像、画布或视频**请求的图片不能跨域**
  2. `toDataURL()`  将canvas转换成图片，返回地址
  3. `createImageData( width, height )`、`createImageData(imageData)`  绘制ImageData对象
  4.` getImageData( x, y, width, height )`  返回ImageData对象，该对象为画布上指定的矩形复制像素数据。
  5. `putImageData( ImageData, x, y )`、`putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )`  把图像数据放回画布上。
  6. `width`  返回ImageData对象的宽度
  7. `height`  返回ImageData对象的高度
  8. `data`  返回一个对象，包含指定的ImageData对象的图像数据

- 保存恢复
  1. `getContext('2d')`  获取2d对象
  2. `save()`  保存当前环境的状态
  3. `restore()`  恢复之前保存过的路径状态和属性

其实目前为止我只用过图片的 `drawImage` 和 `toDataURL` 这俩API。


## 动画

`canvas` 绘制动画有三步骤:

1. 清空 `canvas` （使用 `clearRect()` 或全图绘制）
2. 保存 `canvas` 状态（可选）
3. 绘制动画图形
4. 恢复 `canvas` 状态（一般在第二步的基础上使用）

一般使用下面2种异步API来绘制：

1. `setInterval( function, delay )` `setTimeout( function, delay )`
2. `requestAnimationFrame( function )` `cancelAnimationFrame(frameId)` 览器的刷新频率自动调整动画的时间间隔，一般只有十几毫秒，可用它来做逐帧动画

动画的实质就是由一幅幅不同的静态画面以极快的速度连续播放从而产生物体运动或变化。

## 基本用法

1. `<canvas>`

`<canvas>` 标签只有两个属性—— `width` 和 `height`

`canvas.getContext('2d')` 获取2D上下文

```html
<canvas id="tutorial" width="150" height="150"></canvas>
<script>
    window.onload = function () {
       const canvas = document.getElementById('tutorial');
       const ctx = canvas.getContext('2d');
     }
</script>
```

1. 鼠标在 `canvas` 上的相对坐标位置

用 `pageX` 和 `pageY` 分别减去 `canvas` 元素的左偏移和上偏移距离就可得到相对 `canvas` 的鼠标位置

``` javascript
canvas.addEventListener('mousemove',function(event){
  var x = (event.pageX || event.clientX + document.body.scrollLeft +document.documentElement.scrollLeft) - canvas.offsetLeft;
  var y = (event.pageY || event.clientY + document.body.scrollTop +document.documentElement.scrollTop) - canvas.offsetTop;
  console.log('鼠标在canvas上的相对坐标位置', x, y);
},false);
```

绘图

```javascript
/* 获取画布上下文 */
window.onload = function () {
 const canvas = document.getElementById('tutorial');
 const ctx = canvas.getContext('2d');
 const radius = 3;
 let hasInit = false;
 canvas.addEventListener('mousemove', function (event) {
   var x = (event.pageX || event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft) - canvas.offsetLeft;
   var y = (event.pageY || event.clientY + document.body.scrollTop + document.documentElement.scrollTop) - canvas.offsetTop;
   console.log('鼠标在canvas上的相对坐标位置', x, y);

   if (!hasInit) {
     ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除整个canvas画布
     hasInit = true;
   }

   /* 打开路径开始绘图 */
   ctx.fillStyle = 'red';
   ctx.beginPath();

   /* 绘制一个跟随鼠标的圆 */
   ctx.arc(x, y, radius, 0, 2 * Math.PI, true);
   ctx.fill();
   ctx.closePath();
 }, false);
}
```


## 三角函数

- 弧度与度

角度和弧度都是角的度量单位，一弧度约等于57.2958°，反向计算可得360°（一个完整圆的角度）等于6.2832弧度（也就是2*PI），

所以弧度（radians）和角度（degrees）的转换公式如下：

```javascript
1弧度 = degrees * Math.PI / 180;
1度 = radians * 180 / Math.PI;
```

- 坐标系

数学的坐标系是从左下角开始，`canvas` 的坐标系是从左上角开始

- 直角三角形

x是邻边，y是对边，R是斜边，θ是角度

```javascript
/*三角函数*/
正弦：Math.sin(θ*Math.PI/180)
余弦：Math.cos(θ*Math.PI/180)
正切：Math.tan(θ*Math.PI/180)
/*反三角函数*/
反正弦：Math.asin(y/R)*(180/Math.PI) = θ
反余弦：Math.acos(x/R)*(180/Math.PI) = θ
反正切：Math.atan(y/x)*(180/Math.PI) = θ
```



